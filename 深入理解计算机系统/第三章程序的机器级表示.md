- x86-64的CPU包含一组16个存储64位值的通用目的寄存器。这些寄存器用来存储整数数据和指针。最初8086中有8个16位寄存器，命名为%ax到%bp。每个寄存器都有特殊的用途。扩展到32位架构时，这些寄存器标号从%eax到%ebp。后来扩展到x86-64架构，原来的8个寄存器扩展为64位，标号从%rax到%rbp，除此之外，还增加8个新的寄存器，标号按照新的命名规则：从%r8到%r15。

- 数据传送指令
	- mov S，D    //表示S->D
	- 源操作数指定的值是一个立即数，存储在寄存器中或者内存中。
	- 目的操作数指定一个位置，要么是一个寄存器，要么是一个内存地址。
	- x86-64限制：传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令：第一条指令将源值加载到寄存器中，第二条将该寄存器值写入目的位置。
	- 数据传送实例：
	C代码：
	long exchange（long *xp, long y)
	{
		long x = *xp;
		*xp = y;
		return x;
	}
	gcc生成的汇编代码：（书上生成的，便于理解，用自己设备生成的代码比较复杂）
	//xp in %rdi, y in %rsi
	1 exchange:
	2	movq	(%rdi), %rax     //get x at xp.set as return value.
	3	movq	%rsi, (%rdi)	//store y at xp.
	4	ret                     //return
	解释此汇编代码：%rax寄存器存储的返回值，%rdi存储是第一个参数，%rsi存储的是第二个参数。所以开始的时候，参数xp和y分别存储在寄存器%rdi和%rsi中。然后，指令2从内存中读出x，把它存放到据存起%rax中，直接是实现了C程序中的操作x=*xp。稍后，用据存起%rax从这个函数返回一个值，因而返回值就是x。指令3将y写入到寄存器%rdi中的xp指向的内存位置，直接实现了*xp=y。这个例子说明了如何利用mov指令从内存中读值到寄存器（第2行），如何从寄存器写到内存（第三行）。
	- 指针其实就是地址。间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器。其次像x这样的变量通常是保存在寄存器中，而不是内存。访问寄存器比访问内存要快的多。